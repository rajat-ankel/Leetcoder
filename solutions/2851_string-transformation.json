{
    "problemName": "string-transformation",
    "language": "cpp",
    "code": "class  Solution  {   public :                                       int  numberOfWays ( string  s ,  string  t ,  long  long  k )  {   const  int  n  =  s . length ();   const  int  negOnePowK  =  ( k  %  2  ==  0  ?  1  :  -1 );    const  vector < int >  z  =  zFunction ( s  +  t  +  t );   const  vector < int >  indices  =  getIndices ( z ,  n );   vector < int >  dp ( 2 );    dp [ 1 ]  =  ( modPow ( n  -  1 ,  k )  -  negOnePowK  +  kMod )  %  kMod  *   modPow ( n ,  kMod  -  2 )  %  kMod ;   dp [ 0 ]  =  ( dp [ 1 ]  +  negOnePowK  +  kMod )  %  kMod ;   return  accumulate ( indices . begin (),  indices . end (),  0L ,   [ & ]( long  subtotal ,  int  index )  {   return  ( subtotal  +  dp [ index  ==  0  ?  0  :  1 ])  %  kMod ;   });   }   private :   static  constexpr  int  kMod  =  1'000'000'007 ;   long  modPow ( long  x ,  long  n )  {   if  ( n  ==  0 )   return  1 ;   if  ( n  %  2  ==  1 )   return  x  *  modPow ( x ,  n  -  1 )  %  kMod ;   return  modPow ( x  *  x  %  kMod ,  n  /  2 );   }           vector < int >  zFunction ( const  string &  s )  {   const  int  n  =  s . length ();   vector < int >  z ( n );   int  l  =  0 ;   int  r  =  0 ;   for  ( int  i  =  1 ;  i  <  n ;  ++ i )  {   if  ( i  <  r )   z [ i ]  =  min ( r  -  i ,  z [ i  -  l ]);   while  ( i  +  z [ i ]  <  n  &&  s [ z [ i ]]  ==  s [ i  +  z [ i ]])   ++ z [ i ];   if  ( i  +  z [ i ]  >  r )  {   l  =  i ;   r  =  i  +  z [ i ];   }   }   return  z ;   }       vector < int >  getIndices ( const  vector < int >&  z ,  int  n )  {   vector < int >  indices ;   for  ( int  i  =  n ;  i  <  n  +  n ;  ++ i )   if  ( z [ i ]  >=  n )   indices . push_back ( i  -  n );   return  indices ;   }  }; "
}