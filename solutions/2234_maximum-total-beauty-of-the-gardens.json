{
    "problemName": "maximum-total-beauty-of-the-gardens",
    "language": "cpp",
    "code": "class  Solution  {   public :   long  long  maximumBeauty ( vector < int >&  flowers ,  long  long  newFlowers ,   int  target ,  int  full ,  int  partial )  {   const  int  n  =  flowers . size ();     for  ( int &  flower  :  flowers )   flower  =  min ( flower ,  target );   ranges :: sort ( flowers );     if  ( flowers [ 0 ]  ==  target )   return  static_cast < long > ( n )  *  full ;     if  ( newFlowers  >=  static_cast < long > ( n )  *  target  -   accumulate ( flowers . begin (),  flowers . end (),  0L ))   return  max ( static_cast < long > ( n )  *  full ,   ( n  -  1L )  *  full  +  ( target  -  1L )  *  partial );   long  ans  =  0 ;   long  leftFlowers  =  newFlowers ;     vector < long >  cost ( n );   for  ( int  i  =  1 ;  i  <  n ;  ++ i )     cost [ i ]  =   cost [ i  -  1 ]  +  static_cast < long > ( i )  *  ( flowers [ i ]  -  flowers [ i  -  1 ]);   int  i  =  n  -  1 ;    while  ( flowers [ i ]  ==  target )   -- i ;   for  (;  leftFlowers  >=  0 ;  -- i )  {           const  int  j  =  firstGreater ( cost ,  i ,  leftFlowers );   const  long  minIncomplete  =   flowers [ j  -  1 ]  +  ( leftFlowers  -  cost [ j  -  1 ])  /  j ;   ans  =  max ( ans ,  ( n  -  1L  -  i )  *  full  +  minIncomplete  *  partial );   leftFlowers  -=  max ( 0 ,  target  -  flowers [ i ]);   }   return  ans ;   }   private :   int  firstGreater ( const  vector < long >&  A ,  int  maxIndex ,  long  target )  {   return  upper_bound ( A . begin (),  A . begin ()  +  maxIndex  +  1 ,  target )  -  A . begin ();   }  }; "
}