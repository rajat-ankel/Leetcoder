{
    "problemName": "cat-and-mouse-ii",
    "language": "cpp",
    "code": "class  Solution  {   public :   bool  canMouseWin ( vector < string >&  grid ,  int  catJump ,  int  mouseJump )  {   const  int  m  =  grid . size ();   const  int  n  =  grid [ 0 ]. size ();   int  nFloors  =  0 ;   int  cat ;    int  mouse ;    for  ( int  i  =  0 ;  i  <  m ;  ++ i )   for  ( int  j  =  0 ;  j  <  n ;  ++ j )  {   if  ( grid [ i ][ j ]  !=  '#' )   ++ nFloors ;   if  ( grid [ i ][ j ]  ==  'C' )   cat  =  hash ( i ,  j ,  n );   else  if  ( grid [ i ][ j ]  ==  'M' )   mouse  =  hash ( i ,  j ,  n );   }   vector < vector < vector < int >>>  mem (   m  *  n ,  vector < vector < int >> ( m  *  n ,  vector < int > ( nFloors  *  2 ,  -1 )));   return  canMouseWin ( grid ,  cat ,  mouse ,  0 ,  catJump ,  mouseJump ,  m ,  n ,  nFloors ,   mem );   }   private :   static  constexpr  int  dirs [ 4 ][ 2 ]  =  {{ 0 ,  1 },  { 1 ,  0 },  { 0 ,  -1 },  { -1 ,  0 }};       bool  canMouseWin ( const  vector < string >&  grid ,  int  cat ,  int  mouse ,  int  turn ,   const  int &  catJump ,  const  int &  mouseJump ,  const  int &  m ,   const  int &  n ,  const  int &  nFloors ,   vector < vector < vector < int >>>&  mem )  {     if  ( turn  ==  nFloors  *  2 )   return  false ;   if  ( mem [ cat ][ mouse ][ turn ]  !=  -1 )   return  mem [ cat ][ mouse ][ turn ];   if  ( turn  %  2  ==  0 )  {     const  int  i  =  mouse  /  n ;   const  int  j  =  mouse  %  n ;   for  ( const  auto &  [ dx ,  dy ]  :  dirs )  {   for  ( int  jump  =  0 ;  jump  <=  mouseJump ;  ++ jump )  {   const  int  x  =  i  +  dx  *  jump ;   const  int  y  =  j  +  dy  *  jump ;   if  ( x  <  0  ||  x  ==  m  ||  y  <  0  ||  y  ==  n )   break ;   if  ( grid [ x ][ y ]  ==  '#' )   break ;     if  ( grid [ x ][ y ]  ==  'F' )   return  mem [ cat ][ mouse ][ turn ]  =  true ;   if  ( canMouseWin ( grid ,  cat ,  hash ( x ,  y ,  n ),  turn  +  1 ,  catJump ,   mouseJump ,  m ,  n ,  nFloors ,  mem ))   return  mem [ cat ][ mouse ][ turn ]  =  true ;   }   }     return  mem [ cat ][ mouse ][ turn ]  =  false ;   }  else  {     const  int  i  =  cat  /  n ;   const  int  j  =  cat  %  n ;   for  ( const  auto &  [ dx ,  dy ]  :  dirs )  {   for  ( int  jump  =  0 ;  jump  <=  catJump ;  ++ jump )  {   const  int  x  =  i  +  dx  *  jump ;   const  int  y  =  j  +  dy  *  jump ;   if  ( x  <  0  ||  x  ==  m  ||  y  <  0  ||  y  ==  n )   break ;   if  ( grid [ x ][ y ]  ==  '#' )   break ;     if  ( grid [ x ][ y ]  ==  'F' )   return  mem [ cat ][ mouse ][ turn ]  =  false ;   const  int  nextCat  =  hash ( x ,  y ,  n );     if  ( nextCat  ==  mouse )   return  mem [ cat ][ mouse ][ turn ]  =  false ;   if  ( ! canMouseWin ( grid ,  nextCat ,  mouse ,  turn  +  1 ,  catJump ,  mouseJump ,   m ,  n ,  nFloors ,  mem ))   return  mem [ cat ][ mouse ][ turn ]  =  false ;   }   }     return  mem [ cat ][ mouse ][ turn ]  =  true ;   }   }   int  hash ( int  i ,  int  j ,  int  n )  {   return  i  *  n  +  j ;   }  }; "
}