{
    "problemName": "time-to-cross-a-bridge",
    "language": "cpp",
    "code": "class  Solution  {   public :   int  findCrossingTime ( int  n ,  int  k ,  vector < vector < int >>&  time )  {   int  ans  =  0 ;   using  P  =  pair < int ,  int > ;     priority_queue < P >  leftBridgeQueue ;   priority_queue < P >  rightBridgeQueue ;     priority_queue < P ,  vector < P > ,  greater <>>  leftWorkers ;   priority_queue < P ,  vector < P > ,  greater <>>  rightWorkers ;   for  ( int  i  =  0 ;  i  <  k ;  ++ i )   leftBridgeQueue . emplace (   /*leftToRight*/  time [ i ][ 0 ]  +  /*rightToLeft*/  time [ i ][ 2 ],  i );   while  ( n  >  0  ||  ! rightBridgeQueue . empty ()  ||  ! rightWorkers . empty ())  {     while  ( ! leftWorkers . empty ()  &&  leftWorkers . top (). first  <=  ans )  {   const  int  i  =  leftWorkers . top (). second ;   leftWorkers . pop ();   leftBridgeQueue . emplace (   /*leftToRight*/  time [ i ][ 0 ]  +  /*rightToLeft*/  time [ i ][ 2 ],  i );   }     while  ( ! rightWorkers . empty ()  &&  rightWorkers . top (). first  <=  ans )  {   const  int  i  =  rightWorkers . top (). second ;   rightWorkers . pop ();   rightBridgeQueue . emplace (   /*leftToRight*/  time [ i ][ 0 ]  +  /*rightToLeft*/  time [ i ][ 2 ],  i );   }   if  ( ! rightBridgeQueue . empty ())  {         const  int  i  =  rightBridgeQueue . top (). second ;   rightBridgeQueue . pop ();   ans  +=  /*rightToLeft*/  time [ i ][ 2 ];   leftWorkers . emplace ( ans  +  /*putNew*/  time [ i ][ 3 ],  i );   }  else  if  ( ! leftBridgeQueue . empty ()  &&  n  >  0 )  {             const  int  i  =  leftBridgeQueue . top (). second ;   leftBridgeQueue . pop ();   ans  +=  /*leftToRight*/  time [ i ][ 0 ];   rightWorkers . emplace ( ans  +  /*pickOld*/  time [ i ][ 1 ],  i );   -- n ;   }  else  {     ans  =  min (   ! leftWorkers . empty ()  &&  n  >  0  ?  leftWorkers . top (). first  :  INT_MAX ,   ! rightWorkers . empty ()  ?  rightWorkers . top (). first  :  INT_MAX );   }   }   return  ans ;   }  }; "
}