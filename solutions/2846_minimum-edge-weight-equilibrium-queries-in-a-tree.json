{
    "problemName": "minimum-edge-weight-equilibrium-queries-in-a-tree",
    "language": "cpp",
    "code": "class  Solution  {   public :   vector < int >  minOperationsQueries ( int  n ,  vector < vector < int >>&  edges ,   vector < vector < int >>&  queries )  {   constexpr  int  kMax  =  26 ;   const  int  m  =  log2 ( n )  +  1 ;   vector < int >  ans ;   vector < vector < pair < int ,  int >>>  graph ( n );     vector < vector < int >>  jump ( n ,  vector < int > ( m ));     vector < vector < int >>  count ( n );     vector < int >  depth ( n );   for  ( const  vector < int >&  edge  :  edges )  {   const  int  u  =  edge [ 0 ];   const  int  v  =  edge [ 1 ];   const  int  w  =  edge [ 2 ];   graph [ u ]. emplace_back ( v ,  w );   graph [ v ]. emplace_back ( u ,  w );   }   count [ 0 ]  =  vector < int > ( kMax  +  1 );   dfs ( graph ,  0 ,  /*prev=*/ -1 ,  0 ,  jump ,  count ,  depth );     for  ( int  j  =  1 ;  j  <  m ;  ++ j )   for  ( int  i  =  0 ;  i  <  n ;  ++ i )   jump [ i ][ j ]  =  jump [ jump [ i ][ j  -  1 ]][ j  -  1 ];   for  ( const  vector < int >&  query  :  queries )  {   const  int  u  =  query [ 0 ];   const  int  v  =  query [ 1 ];   const  int  lca  =  getLCA ( u ,  v ,  jump ,  depth );     const  int  numEdges  =  depth [ u ]  +  depth [ v ]  -  2  *  depth [ lca ];     int  maxFreq  =  0 ;   for  ( int  j  =  1 ;  j  <=  kMax ;  ++ j )   maxFreq  =  max ( maxFreq ,  count [ u ][ j ]  +  count [ v ][ j ]  -  2  *  count [ lca ][ j ]);   ans . push_back ( numEdges  -  maxFreq );   }   return  ans ;   }   private :   void  dfs ( const  vector < vector < pair < int ,  int >>>&  graph ,  int  u ,  int  prev ,  int  d ,   vector < vector < int >>&  jump ,  vector < vector < int >>&  count ,   vector < int >&  depth )  {   if  ( prev  !=  -1 )   jump [ u ][ 0 ]  =  prev ;   depth [ u ]  =  d ;   for  ( const  auto &  [ v ,  w ]  :  graph [ u ])  {   if  ( v  ==  prev )   continue ;     count [ v ]  =  count [ u ];     ++ count [ v ][ w ];   dfs ( graph ,  v ,  u ,  d  +  1 ,  jump ,  count ,  depth );   }   }     int  getLCA ( int  u ,  int  v ,  const  vector < vector < int >>&  jump ,   const  vector < int >&  depth )  {     if  ( depth [ u ]  >  depth [ v ])   return  getLCA ( v ,  u ,  jump ,  depth );     for  ( int  j  =  0 ;  j  <  jump [ 0 ]. size ();  ++ j )   if  ( depth [ v ]  -  depth [ u ]  >>  j  &  1 )   v  =  jump [ v ][ j ];   if  ( u  ==  v )   return  u ;     for  ( int  j  =  jump [ 0 ]. size ()  -  1 ;  j  >=  0 ;  -- j )   if  ( jump [ u ][ j ]  !=  jump [ v ][ j ])  {   u  =  jump [ u ][ j ];   v  =  jump [ v ][ j ];   }   return  jump [ v ][ 0 ];   }  }; "
}