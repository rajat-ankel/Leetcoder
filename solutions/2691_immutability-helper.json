{
    "problemName": "immutability-helper",
    "language": "cpp",
    "code": "type  JSONValue  =   |  null   |  boolean   |  number   |  string   |  JSONValue []   |  {  [ key :  string ] :  JSONValue  };  type  InputObj  =  Record < string ,  JSONValue >  |  Array < JSONValue > ;  type  RecursiveHandler  =  {   set :  ( target :  any ,  prop :  string ,  value :  any )  =>  boolean ;   get :  ( target :  any ,  prop :  string )  =>  unknown ;  };  const  isObject  =  ( o :  any )  =>  o  !==  null  &&  typeof  o  ===  'object' ;   class  AccessHistory  {   value :  JSONValue  |  null  =  null ;   props :  Map < string ,  AccessHistory >  =  new  Map ();  }  class  ImmutableHelper  {   private  obj :  InputObj ;   constructor ( obj :  InputObj )  {   this . obj  =  obj ;   }   produce ( mutator :  ( obj :  InputObj )  =>  void ) :  InputObj  {     function  createProxiedObj (   obj :  InputObj ,   accessHistory :  AccessHistory   ) :  InputObj  {   const  handler :  RecursiveHandler  =  {     set ( _ ,  prop ,  value )  {   if  ( ! accessHistory . props . has ( prop ))  {   accessHistory . props . set ( prop ,  new  AccessHistory ());   }   accessHistory . props . get ( prop ) ! . value  =  value ;   return  true ;   },     get ( _ ,  prop )  {   if  ( accessHistory . value  !==  null )  {   return  accessHistory . value ;   }   if  ( ! accessHistory . props . has ( prop ))  {   accessHistory . props . set ( prop ,  new  AccessHistory ());   }   if  ( accessHistory . props . get ( prop ) ! . value  !==  null )  {   return  accessHistory . props . get ( prop ) ! . value ;   }   if  ( isObject ( obj [ prop ]))  {     return  createProxiedObj (   obj [ prop ]  as  InputObj ,   accessHistory . props . get ( prop ) !  as  AccessHistory   );   }   return  obj [ prop ];   },   };   return  new  Proxy ( obj ,  handler );   }       function  deleteUnmutatedProps ( accessHistory :  AccessHistory ) :  boolean  {   if  ( accessHistory . value  !==  null )  {   return  true ;   }   let  hasMutation  =  false ;   for  ( const  [ prop ,  childAccessHistory ]  of  [... accessHistory . props ])  {   if  ( deleteUnmutatedProps ( childAccessHistory ))  {   hasMutation  =  true ;   }  else  {   accessHistory . props . delete ( prop );   }   }   return  hasMutation ;   }     function  transform ( obj :  InputObj ,  accessHistory :  AccessHistory ) :  InputObj  {   if  ( accessHistory . value  !==  null )  {   return  accessHistory . value  as  InputObj ;   }   if  ( accessHistory . props . size  ===  0 )  {   return  obj ;   }   if  ( ! isObject ( obj ))  {   return  obj ;   }   let  clone  =  Array . isArray ( obj )  ?  [... obj ]  :  {  ... obj  };   for  ( const  [ prop ,  childAccessHistory ]  of  [... accessHistory . props ])  {   clone [ prop ]  =  transform ( obj [ prop ]  as  InputObj ,  childAccessHistory );   }   return  clone ;   }   const  accessHistory  =  new  AccessHistory ();   const  proxiedObj  =  createProxiedObj ( this . obj ,  accessHistory );       mutator ( proxiedObj );     deleteUnmutatedProps ( accessHistory );     return  transform ( this . obj ,  accessHistory );   }  } "
}