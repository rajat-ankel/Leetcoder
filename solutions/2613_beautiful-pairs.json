{
    "problemName": "beautiful-pairs",
    "language": "cpp",
    "code": "class  SegmentTree  {   public :   explicit  SegmentTree ( const  vector < int >&  nums )   :  maxNum ( nums . size ()),  nums ( move ( nums )),  tree ( 4  *  maxNum ,  -1 )  {}         void  update ( int  i ,  int  numIndex )  {   update ( 0 ,  0 ,  maxNum ,  i ,  numIndex );   }     int  query ( int  i ,  int  j )  const  {   return  query ( 0 ,  0 ,  maxNum ,  i ,  j );   }   private :     static  constexpr  int  kDefaultValue  =  -1 ;   const  int  maxNum ;   const  vector < int >  nums ;    vector < int >  tree ;    void  update ( int  treeIndex ,  int  lo ,  int  hi ,  int  i ,  int  numIndex )  {   if  ( lo  ==  hi )  {   tree [ treeIndex ]  =  merge ( tree [ treeIndex ],  numIndex );   return ;   }   const  int  mid  =  ( lo  +  hi )  /  2 ;   if  ( i  <=  mid )   update ( 2  *  treeIndex  +  1 ,  lo ,  mid ,  i ,  numIndex );   else   update ( 2  *  treeIndex  +  2 ,  mid  +  1 ,  hi ,  i ,  numIndex );   tree [ treeIndex ]  =  merge ( tree [ 2  *  treeIndex  +  1 ],  tree [ 2  *  treeIndex  +  2 ]);   }   int  query ( int  treeIndex ,  int  lo ,  int  hi ,  int  i ,  int  j )  const  {   if  ( i  <=  lo  &&  hi  <=  j )    return  tree [ treeIndex ];   if  ( j  <  lo  ||  hi  <  i )    return  kDefaultValue ;   const  int  mid  =  ( lo  +  hi )  /  2 ;   return  merge ( query ( 2  *  treeIndex  +  1 ,  lo ,  mid ,  i ,  j ),   query ( 2  *  treeIndex  +  2 ,  mid  +  1 ,  hi ,  i ,  j ));   }       int  merge ( const  int &  i ,  const  int &  j )  const  {   if  ( i  ==  -1 )   return  j ;   if  ( j  ==  -1 )   return  i ;   if  ( nums [ i ]  >  nums [ j ])   return  i ;   if  ( nums [ j ]  >  nums [ i ])   return  j ;   return  min ( i ,  j );   }  };  class  Solution  {   public :   vector < int >  beautifulPair ( vector < int >&  nums1 ,  vector < int >&  nums2 )  {                                     constexpr  int  kInf  =  1'000'000'000 ;   const  int  n  =  nums1 . size ();   vector < int >  ans ( 2 ,  n );   vector < int >  nums2PlusNums1 ;   vector < int >  nums2MinusNums1 ;   vector < int >  indices ;   int  minBeauty  =  INT_MAX ;   for  ( int  i  =  0 ;  i  <  n ;  ++ i )  {   nums2PlusNums1 . push_back ( nums2 [ i ]  +  nums1 [ i ]);   nums2MinusNums1 . push_back ( nums2 [ i ]  -  nums1 [ i ]);   indices . push_back ( i );   }   ranges :: sort ( indices ,   [ & nums2 ]( int  i ,  int  j )  {  return  nums2 [ i ]  <  nums2 [ j ];  });   SegmentTree  tree1 ( nums2PlusNums1 );   SegmentTree  tree2 ( nums2MinusNums1 );   for  ( const  int  i  :  indices )  {   const  int  num  =  nums1 [ i ];       int  j  =  tree1 . query ( 0 ,  num );   if  ( j  >=  0 )   updateAns ( nums2PlusNums1 ,  i ,  j ,  minBeauty ,  ans );   tree1 . update ( num ,  i );       j  =  tree2 . query ( num ,  n );   if  ( j  >=  0 )   updateAns ( nums2MinusNums1 ,  i ,  j ,  minBeauty ,  ans );   tree2 . update ( num ,  i );   }   return  ans ;   }   private :   void  updateAns ( const  vector < int >&  nums ,  int  i ,  int  j ,  int &  minBeauty ,   vector < int >&  ans )  {     const  int  beauty  =  nums [ i ]  -  nums [ j ];   const  vector < int >  nextAns  =  { min ( i ,  j ),  max ( i ,  j )};   if  ( beauty  <  minBeauty )  {   minBeauty  =  beauty ;   ans  =  nextAns ;   }  else  if  ( beauty  ==  minBeauty )  {   ans  =  min ( ans ,  nextAns );   }   }  }; "
}