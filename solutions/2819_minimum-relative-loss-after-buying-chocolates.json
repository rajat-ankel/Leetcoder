{
    "problemName": "minimum-relative-loss-after-buying-chocolates",
    "language": "cpp",
    "code": "class  Solution  {   public :   vector < long  long >  minimumRelativeLosses ( vector < int >&  prices ,   vector < vector < int >>&  queries )  {   const  int  n  =  prices . size ();   vector < long  long >  ans ;   vector < long  long >  prefix { 0 };   ranges :: sort ( prices );   for  ( const  int  price  :  prices )   prefix . push_back ( prefix . back ()  +  price );   for  ( const  vector < int >&  query  :  queries )  {   const  int  k  =  query [ 0 ];   const  int  m  =  query [ 1 ];   const  int  countFront  =  getCountFront ( k ,  m ,  prices ,  prefix );   const  int  countBack  =  m  -  countFront ;   ans . push_back ( getRelativeLoss ( countFront ,  countBack ,  k ,  prefix ));   }   return  ans ;   }   private :                                       int  getCountFront ( int  k ,  int  m ,  const  vector < int >&  prices ,   const  vector < long  long >&  prefix )  {   const  int  n  =  prices . size ();   const  int  countNoGreaterThanK  =   ranges :: upper_bound ( prices ,  k )  -  prices . begin ();   int  l  =  0 ;   int  r  =  min ( countNoGreaterThanK ,  m );   while  ( l  <  r )  {   const  int  mid  =  ( l  +  r )  /  2 ;   const  int  right  =  m  -  mid ;     if  ( prices [ mid ]  <  2L  *  k  -  prices [ n  -  right ])   l  =  mid  +  1 ;   else   r  =  mid ;   }   return  l ;   }       long  getRelativeLoss ( int  countFront ,  int  countBack ,  int  k ,   const  vector < long  long >&  prefix )  {   const  long  lossFront  =  prefix [ countFront ];   const  long  lossBack  =   2L  *  k  *  countBack  -   ( prefix . back ()  -  prefix [ prefix . size ()  -  1  -  countBack ]);   return  lossFront  +  lossBack ;   }  }; "
}